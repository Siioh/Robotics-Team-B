#pragma config(Sensor, dgtl2,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           armLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftFront,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           armRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           mobileGoal,    tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

// -- Define variables --
int errorSpeed = 10;
int currentTimeReading, initialTimeReading, initialLeftEncoderReading, initialRightEncoderReading, currentLeftEncoderReading, currentRightEncoderReading;
volatile float timeDiff, leftReadingDiff, rightReadingDiff;
bool runTimer;

int userWaitTime = 2 //Time between starting and stopping movement when holding a button
int userSpeedFactor = 1; //Dampening factor of motors.  Value of controller is divided by this. Ex: 127/2
int userMobileGoalSpeed = 63; //Speed of other motors
int userArmSpeed = 63;
int userClawSpeed = 63;
string userBotOrientation = "forward"; //Bot starts forward

// -- Define Controls --
string rightDrivetrainCtrl = Ch2;
string leftDrivetrainCtrl = Ch3;
string mobileGoalUpCtrl = Btn7U;
string mobileGoalDownCtrl = Btn7D;
string armUpCtrl = Btn6U;
string armDownCtrl = Btn6D;
string clawOpenCtrl = Btn5U;
string clawCloseCtrl = Btn5D;
string rotationSwitchCtrl = Btn8D; // **Needs control for

// -- Define functions --
void resetEncoders() {
	SensorValue[leftEncoder] = 0; //Reset drivetrain encoders
	SensorValue[rightEncoder] = 0;
}

void motorsForward(int drivetrainSpeed) { //Start drivetrain
	motor[rightFront] = drivetrainSpeed;
	motor[rightBack] = drivetrainSpeed;
	motor[leftFront] = drivetrainSpeed;
	motor[leftBack] = drivetrainSpeed;
}

void armUp() {
	motor[armLeft] = 63;
	motor[armRight] = -63;
}

void armUp() {
	motor[armLeft] = -63;
	motor[armRight] = 63;
}

void mobileGoalUp() {
	motor[mobileGoal] = userMobileGoalSpeed;
}
void mobileGoalDown() {
	motor[mobileGoal] = -userMobileGoalSpeed;
}

void motorsForwardAutoStraighten(int drivetrainSpeed) {
	if(SensorValue[rightEncoder] > SensorValue[leftEncoder]) { //If right moved more, slow it.
		motor[rightFront] = drivetrainSpeed - errorSpeed;
		motor[rightBack] = drivetrainSpeed - errorSpeed;
		} else {
		if(SensorValue[rightEncoder] < SensorValue[leftEncoder]) { //Left moved more?  Slow it.
			motor[leftFront] = drivetrainSpeed - errorSpeed;
			motor[leftBack] = drivetrainSpeed - errorSpeed;
			} else {
			motorsForward(drivetrainSpeed); //If totally straight, go straight.
		}
	}
}



/*void pidDrivetrainControl() {
runTimer = true; //Give timer permission to run
while(<active> for some reason) {
if(currentTimeReading != null) { //If generated a second reading
leftReadingDiff /= timeDiff; //Calculate velocity of the sides in terms of degrees per ms
rightReadingDiff /= timeDiff;

abs(leftReadingDiff - rightReadingDiff); //Error of velocities
}

}
runTimer = false; //Turn timer off
}*/

task checkTimer1() {
	/*while(true) {
	if(runTimer == true) {
	ClearTimer[T1]; //Reset Timer
	initialTimeReading = time1[T1]; //Take start time reading
	resetEncoders(); //Reset Encoders
	initialLeftEncoderReading = SensorValue[leftEncoder]; //Take start encoder readings
	initialRightEncoderReading = SensorValue[rightEncoder];
	while(runTimer == true) {
	if( (time1[T1] - initialTimeReading) > 100) { //If time difference is greater than 100ms
	currentTimeReading = time1[T1]; //Take time value
	currentLeftEncoderReading = SensorValue[leftEncoder]; //Take encoder values
	currentRightEncoderReading = SensorValue[rightEncoder];

	timeDiff = currentTimeReading - initialTimeReading; //Time diff
	leftReadingDiff = currentLeftEncoderReading - initialLeftEncoderReading; //Encoders diff
	rightReadingDiff = currentRightEncoderReading - initialRightEncoderReading;

	ClearTimer[T1]; //Reset Timer
	initialTimeReading = time1[T1]; //Take start time reading
	resetEncoders(); //Reset Encoders
	initialLeftEncoderReading = SensorValue[leftEncoder]; //Take start encoder readings
	initialRightEncoderReading = SensorValue[rightEncoder];
	}
	wait1Msec(10); //Wait 10 ms before restarting this loop
	}
	} else {
	wait1Msec(10); //Wait 10 ms before restarting this loop
	}*/
}

void motorsStop() { //Stop drivetrain
	motor[rightFront] = 0;
	motor[rightBack] = 0;
	motor[leftFront] = 0;
	motor[leftBack] = 0;
}

void allStop() { //Stop all motors
	motor[rightFront] = 0;
	motor[rightBack] = 0;
	motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[mobileGoal] = 0;
	motor[armLeft] = 0;
	motor[armRight] = 0;
	motor[claw] = 0;
}

int rotationCalculate(int orientatedSpeed) {
	if (userBotOrientation == "forward") { //If forward, orientedSpeed is the normal.  Otherwise, make backwards be forwards.
		return orientatedSpeed;
		} else {
		orientatedSpeed *= -1;
		return orientatedSpeed;
	}
}

void joystickControl() { //Joystick control for drivetrain
	if (userBotOrientation == "forward") {
		motor[rightFront] = vexRT[rightDrivetrainCtrl] / userSpeedFactor;
		motor[rightBack] = vexRT[rightDrivetrainCtrl] / userSpeedFactor;
		motor[leftFront] = vexRT[leftDrivetrainCtrl] / userSpeedFactor;
		motor[leftBack] = vexRT[leftDrivetrainCtrl] / userSpeedFactor;
		} else {
		motor[rightFront] = (-vexRT[leftDrivetrainCtrl]) / userSpeedFactor;
		motor[rightBack] = (-vexRT[leftDrivetrainCtrl]) / userSpeedFactor;
		motor[leftFront] = (-vexRT[rightDrivetrainCtrl]) / userSpeedFactor;
		motor[leftBack] = (-vexRT[rightDrivetrainCtrl]) / userSpeedFactor;
	}
}

	void pre_auton()
	{
		// Set bStopTasksBetweenModes to false if you want to keep user created tasks
		// running between Autonomous and Driver controlled modes. You will need to
		// manage all user created tasks if set to false.
		bStopTasksBetweenModes = true;

		// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
		// used by the competition include file, for example, you might want
		// to display your team name on the LCD in this function.
		// bDisplayCompetitionStatusOnLcd = false;

		// All activities that occur before the competition starts
		// Example: clearing encoders, setting servo positions, ...

		resetEncoders();

		StartTask(checkTimer1); //Start checking the timer
	}

	/*---------------------------------------------------------------------------*/
	/*                                                                           */
	/*                              Autonomous Task                              */
	/*                                                                           */
	/*  This task is used to control your robot during the autonomous phase of   */
	/*  a VEX Competition.                                                       */
	/*                                                                           */
	/*  You must modify the code to add your own robot specific commands here.   */
	/*---------------------------------------------------------------------------*/

	// -- Define Variables --


	// -- Define Functions --



	// -- Main autonomous task --
	task autonomous()
	{
		/* 4.25 in diameter wheels
		Circumference = Diameter * pi
		Circumference = 13.345 in
		4.5 ft to mobile goal --> 54 inches
		4.04646 rotationss
		1457 degrees
		*/

		// resetEncoders() performed in pre autonomous
		while(SensorValue[rightEncoder] < 1457 || SensorValue[leftEncoder] < 1457) { //Move distance to goal
			//motorsForward(127);
			//motorsForwardAutoStraighten();
		}
	}

	/*---------------------------------------------------------------------------*/
	/*                                                                           */
	/*                              User Control Task                            */
	/*                                                                           */
	/*  This task is used to control your robot during the user control phase of */
	/*  a VEX Competition.                                                       */
	/*                                                                           */
	/*  You must modify the code to add your own robot specific commands here.   */
	/*---------------------------------------------------------------------------*/
	// -- Need to add limit switches to robot and then add code for mobile goal lift --

	// -- Define Variables --



	// -- Define Functions --



	// -- Main User Control --
	task usercontrol()
	{
		while (true) {
			if (vexRT[rotationSwitchCtrl]) { //Swap rotation
				if(userBotOrientation == "forward") { //If forward, switch to back.  Otherwise, switch back to forward.
					userBotOrientation = "back";
					} else {
					userBotOrientation = "forward";
				}
			}

			joystickControl();

			if (vexRT[mobileGoalUpCtrl]) { //If control to move mobile goal up, then move it up!
				motor[mobileGoal] = userMobileGoalSpeed;
			} else {
				motor[mobileGoal] = 0;
			}

			if (vexRT[mobileGoalDownCtrl]) {
				motor[mobileGoal] = -userMobileGoalSpeed;
				} else {
				motor[mobileGoal] = 0;
			}

			if (vexRT[armUpCtrl]) {
				motor[armLeft] = rotationCalculate(userArmSpeed); //May want to reconsider if arm needs to be recalculated for direction
				motor[armRight] = rotationCalculate(userArmSpeed);
				} else {
				motor[armLeft] = 0;
				motor[armRight] = 0;
			}

			if (vexRT[armDownCtrl]) {
				motor[armLeft] = -rotationCalculate(userArmSpeed); // ^^
				motor[armRight] = -rotationCalculate(userArmSpeed);
				} else {
				motor[armLeft] = 0;
				motor[armRight] = 0;
			}

			if (vexRT[clawOpenCtrl]) {
				motor[claw] = userClawSpeed;
				} else {
				motor[claw] = 0;
			}

			if (vexRT[clawCloseCtrl]) {
				motor[claw] = -userClawSpeed;
				} else {
				motor[claw] = 0;
			}
		}
	}
