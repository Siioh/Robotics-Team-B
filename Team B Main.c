#pragma config(Sensor, dgtl2,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           leftBack,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftMiddle,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightMiddle,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mobileGoalRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           plateMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mobileGoalLeft, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// -- Define Variables --
int errorSpeed = 10;
int currentTimeReading, initialTimeReading, initialLeftEncoderReading, initialRightEncoderReading, currentLeftEncoderReading, currentRightEncoderReading, plateRotationToggle;;
volatile float timeDiff, leftReadingDiff, rightReadingDiff;
bool runTimer;

int userWaitTime = 2 //Time between starting and stopping movement when holding a button
int userSpeedFactor = 1; //Dampening factor of motors.  Value of controller is divided by this. Ex: 127/2
int userMobileGoalSpeed = 63; //Speed of other motors
int userArmSpeed = 63;
int userClawSpeed = 63;
string userBotOrientation = "forward"; //Bot starts forward
// -- End Define Variables --

// -- Define Controls --
string rightDrivetrainCtrl = Ch2;
string leftDrivetrainCtrl = Ch3;
string mobileGoalUpCtrl = Btn6U;
string mobileGoalDownCtrl = Btn6D;
string armUpCtrl = Btn7U;
string armDownCtrl = Btn8U; //Remap later
string clawOpenCtrl = Btn5U;
string clawCloseCtrl = Btn5D;
string rotationSwitchCtrl = Btn8D;
string plateRotationCtrl = Btn7D;
// -- End Define Controls --

// -- Define functions --
void resetEncoders() {
	SensorValue[leftEncoder] = 0; //Reset drivetrain encoders
	SensorValue[rightEncoder] = 0;
}

void motorsForward(int drivetrainSpeed) { //Start drivetrain
	motor[rightFront] = drivetrainSpeed;
	motor[rightBack] = drivetrainSpeed;
	motor[rightMiddle] = drivetrainSpeed;
	motor[leftFront] = drivetrainSpeed;
	motor[leftBack] = drivetrainSpeed;
	motor[leftMiddle] = drivetrainSpeed;
}

/*void armUp() {
motor[armLeft] = 63;
motor[armRight] = -63;
}

void armUp() {
motor[armLeft] = -63;
motor[armRight] = 63;
}*/

void mobileGoalUp() {
	motor[mobileGoalRight] = userMobileGoalSpeed;
	motor[mobileGoalLeft] = userMobileGoalSpeed;
}
void mobileGoalDown() {
	motor[mobileGoalRight] = -userMobileGoalSpeed;
	motor[mobileGoalLeft] = -userMobileGoalSpeed;
}

void motorsForwardAutoStraighten(int drivetrainSpeed) {
	if(SensorValue[rightEncoder] > SensorValue[leftEncoder]) { //If right moved more, slow it.
		motor[rightFront] = drivetrainSpeed - errorSpeed;
		motor[rightBack] = drivetrainSpeed - errorSpeed;
		} else {
		if(SensorValue[rightEncoder] < SensorValue[leftEncoder]) { //Left moved more?  Slow it.
			motor[leftFront] = drivetrainSpeed - errorSpeed;
			motor[leftBack] = drivetrainSpeed - errorSpeed;
			} else {
			motorsForward(drivetrainSpeed); //If totally straight, go straight.
		}
	}
}



/*void pidDrivetrainControl() {
runTimer = true; //Give timer permission to run
while(<active> for some reason) {
if(currentTimeReading != null) { //If generated a second reading
leftReadingDiff /= timeDiff; //Calculate velocity of the sides in terms of degrees per ms
rightReadingDiff /= timeDiff;

abs(leftReadingDiff - rightReadingDiff); //Error of velocities
}

}
runTimer = false; //Turn timer off
}*/

task checkTimer1() {
	/*while(true) {
	if(runTimer == true) {
	ClearTimer[T1]; //Reset Timer
	initialTimeReading = time1[T1]; //Take start time reading
	resetEncoders(); //Reset Encoders
	initialLeftEncoderReading = SensorValue[leftEncoder]; //Take start encoder readings
	initialRightEncoderReading = SensorValue[rightEncoder];
	while(runTimer == true) {
	if( (time1[T1] - initialTimeReading) > 100) { //If time difference is greater than 100ms
	currentTimeReading = time1[T1]; //Take time value
	currentLeftEncoderReading = SensorValue[leftEncoder]; //Take encoder values
	currentRightEncoderReading = SensorValue[rightEncoder];

	timeDiff = currentTimeReading - initialTimeReading; //Time diff
	leftReadingDiff = currentLeftEncoderReading - initialLeftEncoderReading; //Encoders diff
	rightReadingDiff = currentRightEncoderReading - initialRightEncoderReading;

	ClearTimer[T1]; //Reset Timer
	initialTimeReading = time1[T1]; //Take start time reading
	resetEncoders(); //Reset Encoders
	initialLeftEncoderReading = SensorValue[leftEncoder]; //Take start encoder readings
	initialRightEncoderReading = SensorValue[rightEncoder];
	}
	wait1Msec(10); //Wait 10 ms before restarting this loop
	}
	} else {
	wait1Msec(10); //Wait 10 ms before restarting this loop
	}*/
}

void motorsStop() { //Stop drivetrain
	motor[rightFront] = 0;
	motor[rightBack] = 0;
	motor[rightMiddle] = 0;
	motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[leftMiddle] = 0;
}

void allStop() { //Stop all motors
	motor[rightFront] = 0;
	motor[rightBack] = 0;
	motor[rightMiddle] = 0;
	motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[leftMiddle] = 0;
	/*motor[armLeft] = 0;
	motor[armRight] = 0;*/
}

int rotationCalculate(int orientatedSpeed) {
	if (userBotOrientation == "forward") { //If forward, orientedSpeed is the normal.  Otherwise, make backwards be forwards.
		return orientatedSpeed;
		} else {
		orientatedSpeed *= -1;
		return orientatedSpeed;
	}
}

void joystickControl() { //Joystick control for drivetrain
	if (userBotOrientation == "forward") {
		motor[rightFront] = vexRT[rightDrivetrainCtrl] / userSpeedFactor;
		motor[rightBack] = vexRT[rightDrivetrainCtrl] / userSpeedFactor;
		motor[rightMiddle] = vexRT[rightDrivetrainCtrl] / userSpeedFactor;
		motor[leftFront] = vexRT[leftDrivetrainCtrl] / userSpeedFactor;
		motor[leftBack] = vexRT[leftDrivetrainCtrl] / userSpeedFactor;
		motor[leftMiddle] = vexRT[leftDrivetrainCtrl] / userSpeedFactor;
		} else {
		motor[rightFront] = (-vexRT[leftDrivetrainCtrl]) / userSpeedFactor;
		motor[rightBack] = (-vexRT[leftDrivetrainCtrl]) / userSpeedFactor;
		motor[rightMiddle] = (-vexRT[leftDrivetrainCtrl]) / userSpeedFactor;
		motor[leftFront] = (-vexRT[rightDrivetrainCtrl]) / userSpeedFactor;
		motor[leftBack] = (-vexRT[rightDrivetrainCtrl]) / userSpeedFactor;
		motor[leftMiddle] = (-vexRT[rightDrivetrainCtrl]) / userSpeedFactor;
	}
}
// -- End Define Functions --

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

// -- Pre-autonomous task --
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...

	resetEncoders();

	startTask(checkTimer1); //Start checking the timer
}
// -- End Pre-autonomous task --

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

// -- Main autonomous task --
task autonomous()
{
	/* 4.25 in diameter wheels
	Circumference = Diameter * pi
	Circumference = 13.345 in
	4.5 ft to mobile goal --> 54 inches
	4.04646 rotationss
	1457 degrees
	*/

	// resetEncoders() performed in pre autonomous
	/*while(SensorValue[rightEncoder] < 1457 || SensorValue[leftEncoder] < 1457) { //Move distance to goal
	//motorsForward(127);
	//motorsForwardAutoStraighten();
	}*/

	/*motorsForward(127);
	wait1Msec(x);
	motorsStop();
	mobileGoalUp();
	wait1Msec(x);
	allStop();
	motor[leftBack] = 127;
	motor[leftFront] = 127;
	motor[rightBack] = -127;
	motor[rightFront] = -127;
	wait1Msec(x);
	allStop();
	motorsForward(127);
	wait1Msec(x);
	allStop();
	mobileGoalDown();
	wait1Msec();
	allStop();
	motorsForward(-127);
	allStop();
	*/

	clearTimer(T1);
	while (time1[T1] < 7000) {
		motorsForward(127);
	}
	allStop();

}
// -- End autonomous task --

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
// -- Need to add limit switches to robot and then add code for mobile goal lift --

task simultaneousArm() {
	/*while(true) {
		if (vexRT[armUpCtrl] == 1) {
		motor[armLeft] = rotationCalculate(userArmSpeed);
		motor[armRight] = rotationCalculate(userArmSpeed);
		} else if (vexRT[armDownCtrl] == 1) {
		motor[armLeft] = -rotationCalculate(userArmSpeed);
		motor[armRight] = -rotationCalculate(userArmSpeed);
		} else {
		motor[armLeft] = 0;
		motor[armRight] = 0;
		}
	}*/
}

task simultaneousRotation() {
	while(true) {
		if (vexRT[rotationSwitchCtrl] == 1) { //Swap rotation -- **NEEDS REWORK**
			if(userBotOrientation == "forward") { //If forward, switch to back.  Otherwise, switch back to forward.
				userBotOrientation = "back";
				} else {
				userBotOrientation = "forward";
			}
		}
	}
}

task plateRotation() {
	while(true) {
		if (vexRT[plateRotationCtrl] == 1) {
			if(plateRotationToggle == 0) {
				motor[plateMotor] = 30;
				plateRotationToggle = 1;
				} else {
				motor[plateMotor] = 0;
				plateRotationToggle = 0;
			}
		}
	}
}

// -- Start User Control Task --
task usercontrol()
{
	startTask(simultaneousArm);
	startTask(simultaneousRotation);
	startTask(plateRotation);
	while (true) {

		joystickControl();

		if (vexRT[mobileGoalUpCtrl] == 1) {             //If control to move mobile goal up, then move it up!
			motor[mobileGoalLeft] = userMobileGoalSpeed;
			motor[mobileGoalRight] = userMobileGoalSpeed;
			} else if (vexRT[mobileGoalDownCtrl] == 1) {    //Else, check if it should go down
			motor[mobileGoalLeft] = -userMobileGoalSpeed;
			motor[mobileGoalRight] = -userMobileGoalSpeed;
			} else {                                        //If neither up nor down, keep it off.
			motor[mobileGoalLeft] = 0;
			motor[mobileGoalRight] = 0;
		}

		/*if (vexRT[clawOpenCtrl] == 1) {
		motor[claw] = userClawSpeed;
		} else if (vexRT[clawCloseCtrl] == 1) {
		motor[claw] = -userClawSpeed;
		} else {
		motor[claw] = 0;
		}*/

	}
}
// -- End User Control Task --
