#pragma config(Sensor, in1,    gyroscope,      sensorGyro)
#pragma config(Sensor, in2,    rightAngle,     sensorPotentiometer)
#pragma config(Sensor, in3,    leftAngle,      sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           right,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           left,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           mobileGoalLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mobileGoalRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           armLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,           ,             tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

// -- Define Variables --

volatile int gyroReading, currentLeftEncoderReading, currentRightEncoderReading;



int normalSpeed = 127;

int slowSpeed = 90;



int userWaitTime = 50; //Time between starting and stopping movement when holding a button



int userMobileGoalSpeed = 127; //Speed of other motors

int userLeftArmSpeed = 127;

int userRightArmSpeed = 127;



string userBotOrientation = "forward"; //Bot starts forward

// -- End Define Variables --



// -- Define Controls --

string rightDrivetrainCtrl = Ch2;

string leftDrivetrainCtrl = Ch3;

string mobileGoalUpCtrl = Btn6U;

string mobileGoalDownCtrl = Btn6D;

string armUpCtrl = Btn5U;

string armDownCtrl = Btn5D;

string rotationSwitchCtrl = Btn8D;

// -- End Define Controls --



// -- Define functions --

void resetSensors() {

	SensorValue[leftEncoder] = 0; //Reset drivetrain encoders

	SensorValue[rightEncoder] = 0;

	SensorValue[gyroscope] = 0; //Reset gyro

}



/*void motorsForwardAutoStraighten(int drivetrainSpeed) {

if(SensorValue[rightEncoder] > SensorValue[leftEncoder]) { //If right moved more, slow it.

motor[rightFront] = drivetrainSpeed - errorSpeed;

motor[rightBack] = drivetrainSpeed - errorSpeed;

} else {

if(SensorValue[rightEncoder] < SensorValue[leftEncoder]) { //Left moved more?  Slow it.

motor[leftFront] = drivetrainSpeed - errorSpeed;

motor[leftBack] = drivetrainSpeed - errorSpeed;

} else {

motorsForward(drivetrainSpeed); //If totally straight, go straight.

}

}

}*/



/*void pidDrivetrainControl() {

runTimer = true; //Give timer permission to run

while(<active> for some reason) {

if(currentTimeReading != null) { //If generated a second reading

leftReadingDiff /= timeDiff; //Calculate velocity of the sides in terms of degrees per ms

rightReadingDiff /= timeDiff;



abs(leftReadingDiff - rightReadingDiff); //Error of velocities

}



}

runTimer = false; //Turn timer off

}*/



void drivetrainStop() { //Stop drivetrain

	motor[right] = 0;

	motor[left] = 0;

}



void leftMotors(int setSpeed) {

	motor[left] = setSpeed;

}



void rightMotors(int setSpeed) {

	motor[right] = setSpeed;

}



int rotationCalculate(int orientatedSpeed) {

	if (userBotOrientation == "forward") { //If forward, orientedSpeed is the normal.  Otherwise, make backwards be forwards.

		return orientatedSpeed;

		} else {

		orientatedSpeed *= -1;

		return orientatedSpeed;

	}

}



void joystickControl() { //Joystick control for drivetrain

	motor[right] = rotationCalculate(vexRT[rightDrivetrainCtrl]);

	motor[left] = rotationCalculate(vexRT[leftDrivetrainCtrl]);

}



void autonomousStraight(int degreesRotation) {

	while (currentLeftEncoderReading < degreesRotation) {

		if (SensorValue[leftEncoder] < SensorValue[rightEncoder]) {

			leftMotors(normalSpeed);

			rightMotors(slowSpeed);

		}



		if (SensorValue[leftEncoder] > SensorValue[rightEncoder]) {

			leftMotors(slowSpeed);

			rightMotors(normalSpeed);

		}



		if (SensorValue[leftEncoder] == SensorValue[rightEncoder]) {

			leftMotors(normalSpeed);

			rightMotors(normalSpeed);

		}

	}

}



void autonomousTurn(int degreesRotation) {

	if(degreesRotation > gyroReading) {

		while (gyroReading < degreesRotation) {

			leftMotors(-normalSpeed);

			rightMotors(normalSpeed);

		}

		} else {

		while (gyroReading > degreesRotation) {

			leftMotors(normalSpeed);

			rightMotors(-normalSpeed);

		}

	}

	drivetrainStop();



}

// -- End Define Functions --





// -- Define Tasks --

task checkTimer1() {

	/*while(true) {

	if(runTimer == true) {

	ClearTimer[T1]; //Reset Timer

	initialTimeReading = time1[T1]; //Take start time reading

	resetSensors(); //Reset Encoders

	initialLeftEncoderReading = SensorValue[leftEncoder]; //Take start encoder readings

	initialRightEncoderReading = SensorValue[rightEncoder];

	while(runTimer == true) {

	if( (time1[T1] - initialTimeReading) > 100) { //If time difference is greater than 100ms

	currentTimeReading = time1[T1]; //Take time value

	currentLeftEncoderReading = SensorValue[leftEncoder]; //Take encoder values

	currentRightEncoderReading = SensorValue[rightEncoder];



	timeDiff = currentTimeReading - initialTimeReading; //Time diff

	leftReadingDiff = currentLeftEncoderReading - initialLeftEncoderReading; //Encoders diff

	rightReadingDiff = currentRightEncoderReading - initialRightEncoderReading;



	ClearTimer[T1]; //Reset Timer

	initialTimeReading = time1[T1]; //Take start time reading

	resetSensors(); //Reset Encoders

	initialLeftEncoderReading = SensorValue[leftEncoder]; //Take start encoder readings

	initialRightEncoderReading = SensorValue[rightEncoder];

	}

	wait1Msec(10); //Wait 10 ms before restarting this loop

	}

	} else {

	wait1Msec(10); //Wait 10 ms before restarting this loop

	}*/

}



task simultaneousArm() {

	while(true) {

		if (vexRT[armUpCtrl] == 1) {

			motor[armLeft] = userLeftArmSpeed;

			motor[armRight] = userRightArmSpeed;

			} else if (vexRT[armDownCtrl] == 1) {

			motor[armLeft] = -userLeftArmSpeed;

			motor[armRight] = -userRightArmSpeed;

			} else {

			motor[armLeft] = 0;

			motor[armRight] = 0;

		}

	}

}



/*task simultaneousClawArm() {

while(true) {

if (vexRT[clawArmUpCtrl] == 1) {

motor[clawArm] = userClawArmSpeed;

} else if (vexRT[clawArmDownCtrl] == 1) {

motor[clawArm] = -userClawArmSpeed;

} else {

motor[clawArm] = 0;

}

}

}*/



task simultaneousRotation() {

	while(true) {

		if (vexRT[rotationSwitchCtrl] == 1) { //Swap rotation

			if(userBotOrientation == "forward") { //If forward, switch to back.  Otherwise, switch back to forward.

				userBotOrientation = "back";

				} else {

				userBotOrientation = "forward";

			}

			wait1Msec(userWaitTime);

		}

	}

}



/*task simultaneousClaw() {

while(true) {

if (vexRT[clawOpenCtrl] == 1) {

motor[claw] = userClawSpeed;

} else if (vexRT[clawCloseCtrl] == 1) {

motor[claw] = -userClawSpeed;

} else {

motor[claw] = 0;

}

}

}*/



task simultaneousMobileGoal() {

	while (true) {

		if (vexRT[mobileGoalUpCtrl] == 1) {             //If control to move mobile goal up, then move it up!

			motor[mobileGoalLeft] = userMobileGoalSpeed;

			motor[mobileGoalRight] = userMobileGoalSpeed;

			} else if (vexRT[mobileGoalDownCtrl] == 1) {    //Else, check if it should go down

			motor[mobileGoalLeft] = -userMobileGoalSpeed;

			motor[mobileGoalRight] = -userMobileGoalSpeed;

			} else {                                        //If neither up nor down, keep it off.

			motor[mobileGoalLeft] = 0;

			motor[mobileGoalRight] = 0;

		}

	}

}



task getSensorValues() {

	while (true) {

		gyroReading = SensorValue[gyroscope];

		currentRightEncoderReading = -SensorValue[rightEncoder];

		currentLeftEncoderReading = SensorValue[leftEncoder];

		wait1Msec(50);

	}

}

void pre_auton()
{
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// This sets all the encoders to a value of 0
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	SensorValue[gyroscope] = 0;

	motor[mobileGoalRight] = -123;
	motor[mobileGoalLeft] = -123;
	wait1Msec(500);
	motor[mobileGoalRight] = 0;
	motor[mobileGoalLeft] = 0;

	while(SensorValue[rightEncoder] < 1702) {
		motor[right] = 123;
		motor[left] = 123;
	}
	motor[left] = 0;
	motor[right] = 0;


	motor[mobileGoalRight] = 127;
	motor[mobileGoalLeft] = 127;
	wait1Msec(1000);
	motor[mobileGoalRight] = 0;
	motor[mobileGoalLeft] = 0;

	while(SensorValue[gyroscope] <= 1350) {
		if (SensorValue[gyroscope] <= 1000) {
			motor[left] = -127;
			motor[right] = 127;
			} else {
			motor[left] = -50;
			motor[right] = 50;
		}
		wait1Msec(50);
	}
	motor[left] = 0;
	motor[right] = 0;

	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	if(SensorValue[rightEncoder] < 2000){
		motor[right] = 123;
		motor[left] = 123;
	}
	motor[left] = 0;
	motor[right] = 0;

	motor[mobileGoalRight] = -123;
	motor[mobileGoalLeft] = -123;
	wait1Msec(500);
	motor[mobileGoalRight] = 0;
	motor[mobileGoalLeft] = 0;


	motor[right] = -123;
	motor[left] = -123;

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	startTask(simultaneousArm);

	//startTask(simultaneousClawArm);

	//startTask(simultaneousClaw);

	startTask(simultaneousRotation);

	startTask(simultaneousMobileGoal);

	resetSensors();

	startTask(getSensorValues);

	while (true) {

		joystickControl();
	}

}
